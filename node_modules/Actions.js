module.exports = function(ScreenBlocks) {

    var vk = require('VK');
    var settings = require('./screen_settings')();
    var os = require('os');
    var exec = require('exec');
    var notifier = require('node-notifier');

    vk.checkToken();

    var message_id = 0; // переменная для хранения ID беседы
    var can_read = false; // Разрешение на отметку сообщений как прочитанных
    var count_unread_msg = 0; // количество не прочтенных сообщений


    /**
     * Получение списка не прочтенных сообщений
     */
    this.unreadCount = function(callback) {
        vk.request('messages.getDialogs', {
            preview_length: 1,
            count: settings.f_count,
            unread: 1,
            v: 5.25
        }, function(data) {

            if (data && data.response) {

                var count = data.response.count;

                if (count !== count_unread_msg) {
                    if (count > count_unread_msg) {
                        var msg = '';
                        for (var i = 0; i < data.response.items.length; i++) {
                            msg += "\n" + _friend(data.response.items[i].message.user_id);
                        }
                        notice('Получено сообщение [' + count + ']', msg);
                    }

                    count_unread_msg = count;

                    if (callback) {
                        callback();
                    }
                }
            }
        });
    }; // unreadCount


    /**
     * список диалогов слева
     */
    this.getDialogs = function() {
        vk.request('messages.getDialogs', {
            preview_length: 10,
            count: settings.f_count,
            v: 5.25
        }, function(data) {

            if (data && data.response) {

                var mess = data.response.items;
                var str = '';

                for (var j = 0; j < mess.length; j++) {
                    mess[j].message['name'] = _friend(mess[j].message.user_id) +
                        (mess[j].message.out === 1 ? ' » ' : ' « ');
                }

                ScreenBlocks.FriendList.setItems([]);

                for (var i = 0; i < mess.length; i++) {

                    str = '{bold}' + mess[i].message.name + '{/bold} ' + mess[i].message.body +
                        '            __|' + mess[i].message.user_id + '|__';

                    if (mess[i].message.read_state === 0) {
                        str = '{red-fg}' + str + '{/red-fg}';
                    }

                    ScreenBlocks.FriendList.add(str);
                }

                ScreenBlocks.FriendList.parent.render();
            }
        });
    }; // End getDialogs



    /**
     * получение сообщений диалога
     */
    this.getHistory = function(id) {

        if (id !== undefined) {
            message_id = id;
        } else if (message_id === 0) {
            return false;
        }

        vk.request('messages.getHistory', {
            v: 5.25,
            count: settings.history_count,
            user_id: message_id
        }, function(data) {

            if (data.error && data.error.error_msg) {
                ScreenBlocks.messages.setContent(data.error.error_msg);
                ScreenBlocks.messages.parent.render();
                return false;
            }

            var content = '';

            if (data && data.response && data.response.items) {

                var r = data.response.items;
                var mid = []; // id прочитанных сообщений

                for (var i = r.length - 1; i >= 0; i--) {
                    mid.push(r[i].id);

                    content += '{bold}' + _friend(r[i].from_id) + '{/bold} ' +
                        '  ' + _date(r[i].date) + "\n" +
                        getAttach(r[i].attachments) +
                        r[i].body +
                        "\n\n";
                }

                // Сообщение прочтено
                read(mid);

            } else {
                // если возникла ошибка
                content = JSON.stringify(data, undefined, 2);
            }

            content = content.replace(/\n+$/, '');

            ScreenBlocks.messages.setContent(content);
            ScreenBlocks.messages.setScrollPerc(100);
            ScreenBlocks.messages.parent.render();
        });
    }; // End getHistory


    /**
     * отправка сообщения пользователю
     */
    this.send = function(Text) {

        if (message_id === 0 || Text === '' || Text === undefined) {
            return false;
        }

        can_read = true;

        vk.request('messages.send', {
            user_id: message_id,
            message: Text,
            v: 5.25
        }, function(data) {

            ScreenBlocks.txt.clearValue();

            setTimeout(function() {
                getHistory(message_id);
            }, 500);

        });
    }; // End send



    /**
         _                __                  _   _
        | |              / _|                | | (_)
      __| | ___  _ __   | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
     / _` |/ _ \| '_ \  |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
    | (_| | (_) | |_) | | | | |_| | | | | (__| |_| | (_) | | | \__ \
     \__,_|\___/| .__/  |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
                | |
                |_|
    */



    // ==================================
    // получение id пользователя которого выбираем в списке
    this.getID = function(str) {
        var re = /__\|(\d+)\|__/g;
        var myArray = re.exec(str);

        if (myArray && myArray[1]) {
            return myArray[1];
        } else {
            return false;
        }
    };



    // ===============================
    // Отображение вложений в сообщении
    var getAttach = function(obj, not_red) {
        var msg = '';

        if (obj === undefined) {
            return msg;
        }

        if (not_red === undefined) {
            msg += "{red-fg}✪ ✪ ✪ attach ✪ ✪ ✪ \n";
        }

        for (var i = 0; i < obj.length; i++) {
            if (obj[i].type === 'photo') {
                msg += (obj[i].photo.photo_604 + "\n");
            }

            if (obj[i].type === 'wall') {
                if (obj[i].wall && obj[i].wall.text) {
                    msg += obj[i].wall.text + "\n\n";
                }

                if (obj[i].wall && obj[i].wall.attachments) {
                    msg += getAttach(obj[i].wall.attachments, true);
                }
            }

            if (obj[i].type === 'audio') {
                msg += (' === ♪ ♫ ♪ ♫ ♪ ===\n{bold}' + obj[i].audio.artist + '{/bold} ' + obj[i].audio.title + "\n");

            }
        }

        if (not_red === undefined) {
            msg += "{/red-fg}";
        }

        return msg;
    };



    // ==================================
    //  Отобразить сообщения как прочитанные. Передается массив с id сообщений
    this.messageAsReadest = function() {
        can_read = true;
    };

    this.read = function(mid) {
        if (can_read) {
            if (mid.length > 0) {
                vk.request('messages.markAsRead', {
                    mids: mid.join(',')
                }, function(data) {
                    // can_read = true;
                    getDialogs();
                });
            }
            can_read = false;
        }
    };



    // ==================================
    //    Отображать дату в нужном формате
    var f = function(d) {
        return (d < 10 ? '0' + d : d);
    };

    this._date = function(date) {
        var d = new Date(date * 1000);

        return f(d.getHours()) + ':' + f(d.getMinutes()) + '  ' + f(d.getDate()) + '.' + f(d.getMonth()) + '.' + d.getFullYear();
    };



    // ===================================
    // Оборажение уведомлений в ОС
    var notice = function(t, msg) {
        /*
        if (os.platform() === 'linux' && process.env.KDE_SESSION_VERSION !== undefined) {
            exec('kdialog --title " ' + (t || '') + ' " --passivepopup " ' + (msg || '') + ' "', function(err, out, code) {
                if (err instanceof Error)
                    throw err;
                // process.stderr.write(err);
                // process.stdout.write(out);
                // process.exit(code);
            });
        } else
        */
        try {
            notifier.notify({
                title: t,
                message: msg,
                icon: __dirname + '/../icon.png', // absolute path (not balloons)
                sound: false, // Only Notification Center or Windows Toasters
                wait: false // wait with callback until user action is taken on notification
            }, function(err, response) {
                // response is response from notification
                // console.log(err);
            });
        } catch (e) {
            // return false;
        }
    };



    // ==================================
    // массив со списком друзей
    var uidFriends = {};
    var user_ids = [];

    // ==================================
    // функция для отображения имени друга
    var _friend = function(id) {

        if (uidFriends[id] !== undefined) {
            return uidFriends[id];
        }

        user_ids.push(id);

        setTimeout(function() {

            if (user_ids.length === 0) {
                return false;
            }

            for (var i in user_ids) {
                user_ids[i] = parseInt(user_ids[i], 10);
            }


            if (user_ids.length > 0) {

                vk.request('users.get', {
                    user_ids: user_ids.join(','),
                    fields: 'verifieds',
                    name_case: 'Nom',
                    v: 5.8
                }, function(data) {

                    if (data && data.response) {

                        for (var i = 0; i < data.response.length; i++) {
                            uidFriends[data.response[i].id] = data.response[i].first_name + ' ' + data.response[i].last_name;
                        }

                        user_ids = [];

                    }

                });

            }

        }, 300);

        return id;
    };



    // =========================================
    // Добавляем свое имя в список пользователей
    _friend(require(__dirname + '/token.json').user_id);


    return this;
};